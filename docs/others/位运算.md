# 位运算

位运算符号：**&**、**|**、**^**、**~**、**>>**、**<<**

## 位运算概述

在现代计算机中，所有数据都以二进制形式存储，即 **0** 和 **1** 两种状态。计算机对二进制数据进行的运算（比如 加、减、乘、除）被称为位运算，即对二进制数的每一位进行操作的运算。

为了更好地理解位运算，举个简单的例子：假设我们有如下代码进行两个整数的加法运算：

```c
int a = 35;
int b = 47;
int c = a + b;
```

计算机会将这两个整数转换为二进制形式，然后进行加法运算：

```c
35: 0010 0011
47: 0010 1111
----------------
82: 0101 0010
```

因此，与直接使用+、-、\*、/运算符相比，合理运用位运算可以显著提高代码在机器上的执行效率。

## 位运算概览

| 符号 | 描述 | 运算规则                                        |
| ---- | ---- | ----------------------------------------------- |
| &    | 与   | 两个位都位 `1` 时，结果才为 `1`                 |
| \|   | 或   | 两个位都为 `0` 时，结果才为 `0`                 |
| ^    | 异或 | 两个位相同为 `0`，相异为 `1`                    |
| ~    | 取反 | `0` 变 `1`，`1` 变 `0`                          |
| \<\< | 左移 | 各二进制全部左移若干位，高位丢弃，低位补 `0`    |
| >>   | 右移 | 各二进制全部右移若干位，高位补 `0` 或符号位补齐 |

## 按位与运算符（&）

对参与运算的两个数据的二进制位进行与“与”运算。

```c
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1
```

### 总结

只有两位同时为`1`时，结果才为`1`，否则结果为`0`。例如，`3 & 5` 即 `0000 0011 & 0000 0101`，因此 `3 & 5` 的值为 `1`。

### 注意

PS: 负数按补码形式参与按位与运算。

### 用途

1. **清零**：如果想将一个单元清零，只要与一个各位都为零的数值相与，结果为零。
2. **取 k 一个数的指定位**：例如，取数 `X = 1010 1110` 的低 4 位，只需另找一个数 `Y = 0000 1111`，然后 `X & Y = 0000 1110` 即可得到 X 的指定位。
3. **判断奇偶**：通过判断最末位是 `0` 还是 `1` 来决定奇偶，可以用 `if ( ( a & 1) === 0 )` 代替 `if ( a % 2 === 0 )` 来判断 `a` 是否为偶数。

## 按位或运算符（|）

对参与运算的两个对象的二进制位进行“或”运算。

```c
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1
```

### 总结

只要有一个为`1`，其值为`1`。例如， `3 | 5` 即 `0000 0011 | 0000 0101 = 0000 0111`，因此 `3 | 5` 的值为 `7`。

### 注意

负数按补码形式参与按位或运算。

### 用途

1. **设置某些位为 1**：例如，将数 `X = 1010 1110` 的低 4 位设置为 `1`，只需另找一个数 `Y = 0000 1111`，然后 `X | Y = 1010 1111` 即可得到。

## 异或运算符（^）

对参与运算的两个数据的二进制位进行“异或”运算。

```c
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
```

### 总结

相应位相同为 `0`，相异为 `1`。

### 性质

1. 交换律
2. 结合律：`(a ^ b) ^ c == a ^ (b ^ c)`
3. 对于任何数 `x`，都有 `x ^ x = 0`, `x ^ 0 = x`
4. 自反性：`a ^ b ^ b = a ^ 0 = a`

### 用途

1. **翻转指定位**：例如，将数 `X = 1010 1110` 的低 4 位翻转，只需另找一个数 `Y = 0000 1111`，然后 `X ^ Y = 1010 0001` 即可得到。
2. **与 0 相异或值不变**：例如 `1010 1110 ^ 0000 0000 = 1010 1110`
3. **交换两个数**：

```c
void swap (int &a, int &b) {
  if (a != b) {
    a ^= b;
    b ^= a;
    a ^= b;
  }
}
```

## 取反运算符（~）

对参与运算的一个数据的二进制位进行“取反”运算。

```c
~1 = 1111 1110   // ~1 = -2
~0 = 1111 1111   // ~0 = -1
```

### 总结

将 0 变 1，1 变 0。

### 用途

1. **使一个数的最低位为零**：例如，使 a 的最低位为 0，可以表示为：`a & ~1`。`~1` 的值为 `1111 1111 1111 1110`，再按“与”运算，最低位一定为 0。

## 左移运算符（\<\<）

将一个运算对象的各二进制位全部左移若干位，高位丢弃，低位补 0。例如，设置 `a = 1010 1110`，`a = a << 2` 将 `a` 的二进制位左移 2 位、右补 0，即得 `a = 1011 1000`。

若左移时舍弃的高位不包含 1，则每左移一位，相当于该数乘以 2。

## 右移运算符（>>）

将一个数的各二进制位全部右移若干位，高位补 0 或补符号位，右边丢弃。例如，`a = a >> 2` 将 a 的二进制位右移 2 位，左补 0 或补符号位，具体取决于数的正负。

操作数每右移一位，相当于该数除以 2。

## 复合赋值运算符

位运算与复制运算符结合，组合新的复合赋值运算符，它们是：

- **&=** 例：`a &= b` 相当于 `a = a & b`
- **|=** 例：`a |= b` 相当于 `a = a | b`
- **>>=** 例：`a >>= b` 相当于 `a = a >> b`
- **<<=** 例：`a <<= b` 相当于 `a = a << b`
- **^=** 例： `a ^= b` 相当于 `a = a ^ b`

运算规则与前述的复合赋值运算符的运算规则相似。

### 不同长度的数据进行位运算

如果两个不同长度的数据进行位运算，系统会将两者按右端对齐，然后进行位运算。

以“与运算”为例说明如下：

在 C 语言中，long 类型占 4 个字节，int 类型占 2 个字节。如果一个 long 类型数据与一个 int 类型数据进行“与”运算，右端对齐后，左边不足的位按以下三种情况补足：

1. 如果整型数据为正数，左边补 16 个 0。
2. 如果整型数据为负数，左边补 16 个 1。
3. 如果整型数据为无符号数，左边也补 16 个 0。

例如：

```c
long a = 123;
int b = 1;
long result = a & b;
```

```c
long a = 123;
unsigned int b = 1;
long result = a & b;
```
