# 十大排序算法

排序算法可以分为**内部排序**和**外部排序**。**内部排序**是数据记录在内存中进行排序，而**外部排序**是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常见的内部排序算法有：**冒泡排序**、**选择排序**、**插入排序**、**希尔排序**、**归并排序**、**快速排序**、**堆排序**、**计数排序**、**桶排序**和**基数排序**等，本文将依次介绍这十大排序算法，希望对您有帮助。

## 关于时间复杂度

![排序算法复杂度](/vite_assets/sort.png)

## 关于稳定性

![算法对比](/vite_assets/sort_diff.png)

## 一、冒泡排序

### 思路与算法

冒泡排序是一种简单直观的排序算法。它重复地走访过每一个要排序的数列，一次比较两个元素，如果顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说这个数列已经排列完成。这个算法的名字由来是因为越小的元素会经过交换慢慢“浮”到数列的顶端。

冒泡排序有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该数列已经有序。_但这种改进对于提升性能来说并没有什么太大作用。_

![思路与算法](/vite_assets/bubble_sort.gif)

### 算法步骤

- 比较相邻的元素，如果【a > b】，就做交换。
- 对每一对相邻的元素【a、b】进行同样的工作。这一步做完，最大的元素【max】已经排到了最后。
- 重复上面步骤，排除上一步的最后一个元素【max】（这时候，数组会越来越短）。
- 持续上述步骤，直到没有元素可以比较。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#bubble-sort

### 复杂度分析

1. 时间复杂度：O(n<sup>2</sup>)
2. 空间复杂度：O(1)
3. 排序方式：In-place
4. 稳定性：稳定

---

## 二、选择排序

### 思路与算法

选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n<sup>2</sup>)的时间复杂度。所以用到它的时候，数据规模越来越小。唯一的好处可能就是不占用额外的内存空间吧。

![冒泡排序](/vite_assets/selection_sort.gif)

### 算法步骤

1. 首先在未排序的数列中找到最小的元素。
2. 将起始位置的元素与最小元素进行交换。
3. 重复上面的操作，直至没有元素可以比较。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#selection-sort

### 复杂度分析

- 时间复杂度：O(n<sup>2</sup>)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

---

## 三、插入排序

### 思路与算法

插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序数列，对于未排序数据，在已排序数列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做折半插入。

![插入排序](/vite_assets/insertion_sort.gif)

### 算法步骤

1. 将数组分成两段，前一段代表已排序数列【A】，后一段代表未排序数列【B】。
2. 将当前元素和已排序数组【A】进行比较，并整理成有序数列。
3. 重复上述步骤，直到清空未排序数列【B】。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#insertion-sort

### 复杂度分析

- 时间复杂度：O(n<sup>2</sup>)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：稳定

---

## 四、希尔排序

### 思路与算法

希尔排序，也称**递减增量排序算法**，是插入排序的一种更高效的改进版本。但希尔排序是*非稳定排序算法*。希尔排序是基于插入排序的一下两点性质而提出改进方法的：

- `插入排序`在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想：先将整个待排序分割成为若干子数列分别进行`插入排序`，待整个数列中的记录“基本有序”时，再对全体记录进行依次`插入排序`。

![希尔排序](/vite_assets/shell_sort.gif)

### 算法步骤

1. 选择一个增量数列 t1, t2, ... tk；
2. 按增量数列个数【k】，对数列进行【k】趟排序；
3. 每趟排序，根据对应的增量【ti】，将待排数列分割成若干长度为【m】的子数列，分别对各子表进行插入排序。仅增量因子为 1 时，整个序列作为一个表来进行处理，表长度即为整个数列的长度。

- [图解排序算法(二)之希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#shell-sort

### 复杂度分析

- 时间复杂度：O(n*log*n)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

---

## 五、归并排序

### 思路与算法

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归
- 自下而上的迭代

和选择一样，归并排序的性能不受输入数据的影响，但表现比选择排序好得多，因为始终都是（n*log*n）的时间复杂度。代价是需要额外的内存空间。

![归并排序](/vite_assets/merge_sort.gif)

### 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#merge-sort{11-27}

### 复杂度分析

- 时间复杂度：O(n*log*n)
- 空间复杂度：O(n)
- 排序方式：Out-place
- 稳定性：稳定

---

## 六、快速排序

### 思路与算法

快速排序又是一种分而治之思想在排序上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的简单粗暴，因为一听到名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n<sup>2</sup>)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n*log*n)的排序算法表现要更好，这是为什么呢？我认为可以查看《算法艺术与信息学竞赛》上找到满意的答案：

> 快速排序的最坏运行情况是 O(n<sup>2</sup>)，比如说顺序数列的快排。但它的平摊期望时间是 O(n*log*n)，且 O(n*log*n) 记号中隐含的常数因子很小，比复杂度稳定等于 O(n*log*n) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

![快速排序](/vite_assets/quick_sort.gif)

### 算法步骤

1. 从数列中挑出一个元素，称为“基准”（pivot）；
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#quick-sort

### 复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(log n)
- 排序方式：In-place
- 稳定性：不稳定

---

## 七、堆排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#heap-sort

### 复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

---

## 八、计数排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#counting-sort

### 复杂度分析

- 时间复杂度：O(n + k)
- 空间复杂度：O(k)
- 排序方式：Out-place
- 稳定性：稳定

---

## 九、桶排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#bucket-sort

### 复杂度分析

- 时间复杂度：O(n + k)
- 空间复杂度：O(n + k)
- 排序方式：Out-place
- 稳定性：稳定

---

## 十、基数排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#radix-sort

### 复杂度分析

- 时间复杂度：O(n \* k)
- 空间复杂度：O(n + k)
- 排序方式：Out-place
- 稳定性：稳定

---

## 名词解释

### 排序算法的稳定性是什么？

### 有哪些排序方式？
