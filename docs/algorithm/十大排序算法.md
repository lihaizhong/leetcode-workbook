# 十大排序算法

排序算法可以分为**内部排序**和**外部排序**。**内部排序**是数据记录在内存中进行排序，而**外部排序**是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常见的内部排序算法有：**冒泡排序**、**选择排序**、**插入排序**、**希尔排序**、**归并排序**、**快速排序**、**堆排序**、**计数排序**、**桶排序**和**基数排序**等，本文将依次介绍这十大排序算法，希望对您有帮助。

## 关于时间复杂度

![排序算法复杂度](/vite_assets/sort.png)

## 关于稳定性

![算法对比](/vite_assets/sort_diff.png)

## 一、冒泡排序

### 思路与算法

冒泡排序是一种简单直观的排序算法。它重复地走访过每一个要排序的数列，一次比较两个元素，如果顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说这个数列已经排列完成。这个算法的名字由来是因为越小的元素会经过交换慢慢“浮”到数列的顶端。

冒泡排序有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该数列已经有序。*但这种改进对于提升性能来说并没有什么太大作用。*

![思路与算法](/vite_assets/bubble_sort.gif)

### 算法步骤

- 比较相邻的元素，如果【a > b】，就做交换。
- 对每一对相邻的元素【a、b】进行同样的工作。这一步做完，最大的元素【max】已经排到了最后。
- 重复上面步骤，排除上一步的最后一个元素【max】（这时候，数组会越来越短）。
- 持续上述步骤，直到没有元素可以比较。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#bubble-sort

### 复杂度分析

1. 时间复杂度：O(n<sup>2</sup>)
2. 空间复杂度：O(1)
3. 排序方式：In-place
4. 稳定性：稳定

----

## 二、选择排序

### 思路与算法

选择排序是一种简单直观的排序算法，无论什么数据进去都是O(n<sup>2</sup>)的时间复杂度。所以用到它的时候，数据规模越来越小。唯一的好处可能就是不占用额外的内存空间吧。

![思路与算法](/vite_assets/selection_sort.gif)

### 算法步骤

1. 首先在未排序的数列中找到最小的元素。
2. 将起始位置的元素与最小元素进行交换。
3. 重复上面的操作，直至没有元素可以比较。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#selection-sort

### 复杂度分析

- 时间复杂度：O(n<sup>2</sup>)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

----

## 三、插入排序

### 思路与算法

插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序数列，对于未排序数据，在已排序数列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做折半插入。

![思路与算法](/vite_assets/insertion_sort.gif)

### 算法步骤

1. 将数组分成两段，前一段代表已排序数列【A】，后一段代表未排序数列【B】。
2. 将当前元素和已排序数组【A】进行比较，并整理成有序数列。
3. 重复上述步骤，直到清空未排序数列【B】。

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#insertion-sort

### 复杂度分析

- 时间复杂度：O(n<sup>2</sup>)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：稳定

----

## 四、希尔排序

### 思路与算法

希尔排序，也称**递减增量排序算法**，是插入排序的一种更高效的改进版本。但希尔排序是*非稳定排序算法*。希尔排序是基于插入排序的一下两点性质而提出改进方法的：

- `插入排序`在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想：先将整个待排序分割成为若干子数列分别进行`插入排序`，待整个数列中的记录“基本有序”时，再对全体记录进行依次`插入排序`。

![思路与算法](/vite_assets/shell_sort.gif)

### 算法步骤

1. 选择一个增量数列t1, t2, ... tk；
2. 按增量数列个数【k】，对数列进行【k】趟排序；
3. 每趟排序，根据对应的增量【ti】，将待排数列分割成若干长度为【m】的子数列，分别对各子表进行插入排序。仅增量因子为1时，整个序列作为一个表来进行处理，表长度即为整个数列的长度。

- [图解排序算法(二)之希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#shell-sort

### 复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

----

## 五、归并排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#merge-sort

### 复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(n)
- 排序方式：Out-place
- 稳定性：稳定

----

## 六、快速排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#quick-sort

### 复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(log n)
- 排序方式：In-place
- 稳定性：不稳定

----

## 七、堆排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#heap-sort

### 复杂度分析

- 时间复杂度：O(n log n)
- 空间复杂度：O(1)
- 排序方式：In-place
- 稳定性：不稳定

----

## 八、计数排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#counting-sort

### 复杂度分析

- 时间复杂度：O(n + k)
- 空间复杂度：O(k)
- 排序方式：Out-place
- 稳定性：稳定

----

## 九、桶排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#bucket-sort

### 复杂度分析

- 时间复杂度：O(n + k)
- 空间复杂度：O(n + k)
- 排序方式：Out-place
- 稳定性：稳定

----

## 十、基数排序

### 思路与算法

### 算法步骤

### 代码实现

<<< ../../src/private/SortingAlgorithm/index.ts#radix-sort

### 复杂度分析

- 时间复杂度：O(n * k)
- 空间复杂度：O(n + k)
- 排序方式：Out-place
- 稳定性：稳定

----

## 名词解释

### 排序算法的稳定性是什么？

### 有哪些排序方式？
