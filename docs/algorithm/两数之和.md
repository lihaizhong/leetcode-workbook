# 两数之和

给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出**和**为目标值`target`的那**两个整数**，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

[去做题](https://leetcode.cn/problems/two-sum/description/)

## 方法一：暴力枚举

### 思路与算法

我们需要在`nums`中找到两个值（**n1, n2**），相加的结果等于`target`。从人最初的思维角度考虑，我假定**n1**已经确定（*循环一遍`nums`*），我们就可以求得`n2 = target - n1`。然后，我们拿着**n2**去`nums`中查找是否有这个值（*循环遍历一遍`nums`*）。因为题目保证仅存在一个答案，故遍历过程中只要存在一个解，即可返回结果。代码如下：

<<< ../../packages/leetcode/src/1.两数之和.ts#two-sum-1

### 复杂度分析

- **时间复杂度：O(n<sup>2</sup>)**，`n`是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。
- **空间复杂度：O(1)**

## 方法二：哈希表

### 思路与算法

前面我们用人最初的思维模式想到了**方法一**来解决问题。但是*电脑毕竟不是人，它有自己的运行逻辑和存储方式*。现在我们再遵循电脑的运行逻辑做优化。我们注意到，寻找`target - n1`的时间复杂度过高了，是可以优化的。那我们应该怎么做呢？从已知的数据结构中查找，我们发现**哈希表**能有效地帮助我们降低时间复杂度(`O(n) -> O(1)`)。

做法是，我们将已经匹配过的元素以及它的索引存到**哈希表**中，然后从**哈希表**中查找计算出的值即可（*利用的是哈希表方便读取的特点*）。

<<< ../../packages/leetcode/src/1.两数之和.ts#two-sum

### 复杂度分析

- **时间复杂度：O(n)**，其中`n`是数组中的元素数量。对于每一个元素`x`，我们可以O(1)地寻找`target - x`。
- **空间复杂度：O(n)**，其中`n`是数组中的元素数量。主要为哈希表的开销。

## 总结

我们比较两种算法的**时间复杂度**和**空间复杂度**。我认为**绝大多数情况，方法二是优于方法一的**。因为我们无法改变时间，但是我们可以通过升级硬件来提升空间。当然，算法的优劣仍需要考虑实际场景。算法没有绝对的好与坏之分，只有最适合当前场景的算法。
